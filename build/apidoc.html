<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://facebook.github.io/watchman/"

    >fb-watchman (v2.0.0)</a>
</h1>
<h4>Bindings for the Watchman file watching service</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fb-watchman">module fb-watchman</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client">
            function <span class="apidocSignatureSpan">fb-watchman.</span>Client
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fb-watchman.</span>Client.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fb-watchman.Client">module fb-watchman.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.Client">
            function <span class="apidocSignatureSpan">fb-watchman.</span>Client
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.super_">
            function <span class="apidocSignatureSpan">fb-watchman.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fb-watchman.Client.prototype">module fb-watchman.Client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype._synthesizeCapabilityCheck">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>_synthesizeCapabilityCheck
            <span class="apidocSignatureSpan">( resp, optional, required)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.cancelCommands">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>cancelCommands
            <span class="apidocSignatureSpan">(why)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.capabilityCheck">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>capabilityCheck
            <span class="apidocSignatureSpan">(caps, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.command">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>command
            <span class="apidocSignatureSpan">(args, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.connect">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.end">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fb-watchman.Client.prototype.sendNextCommand">
            function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>sendNextCommand
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fb-watchman" id="apidoc.module.fb-watchman">module fb-watchman</a></h1>


    <h2>
        <a href="#apidoc.element.fb-watchman.Client" id="apidoc.element.fb-watchman.Client">
        function <span class="apidocSignatureSpan">fb-watchman.</span>Client
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(options) {
  var self = this;
  EE.call(this);

  this.watchmanBinaryPath = &#x27;watchman&#x27;;
  if (options &#x26;&#x26; options.watchmanBinaryPath) {
    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
  };
  this.commands = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fb-watchman.Client" id="apidoc.module.fb-watchman.Client">module fb-watchman.Client</a></h1>


    <h2>
        <a href="#apidoc.element.fb-watchman.Client.Client" id="apidoc.element.fb-watchman.Client.Client">
        function <span class="apidocSignatureSpan">fb-watchman.</span>Client
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(options) {
  var self = this;
  EE.call(this);

  this.watchmanBinaryPath = &#x27;watchman&#x27;;
  if (options &#x26;&#x26; options.watchmanBinaryPath) {
    this.watchmanBinaryPath = options.watchmanBinaryPath.trim();
  };
  this.commands = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.super_" id="apidoc.element.fb-watchman.Client.super_">
        function <span class="apidocSignatureSpan">fb-watchman.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fb-watchman.Client.prototype" id="apidoc.module.fb-watchman.Client.prototype">module fb-watchman.Client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype._synthesizeCapabilityCheck" id="apidoc.element.fb-watchman.Client.prototype._synthesizeCapabilityCheck">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>_synthesizeCapabilityCheck
        <span class="apidocSignatureSpan">( resp, optional, required)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_synthesizeCapabilityCheck = function ( resp, optional, required) {
  resp.capabilities = {}
  var version = resp.version;
  optional.forEach(function (name) {
    resp.capabilities[name] = have_cap(version, name);
  });
  required.forEach(function (name) {
    var have = have_cap(version, name);
    resp.capabilities[name] = have;
    if (!have) {
      resp.error = &#x27;client required capability `&#x27; + name +
                   &#x27;` is not supported by this server&#x27;;
    }
  });
  return resp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (error) {
  done(error);
  return;
}
if (!(&#x27;capabilities&#x27; in resp)) {
  // Server doesn&#x27;t support capabilities, so we need to
  // synthesize the results based on the version
  resp = self.<span class="apidocCodeKeywordSpan">_synthesizeCapabilityCheck</span>(resp, optional, required);
  if (resp.error) {
    error = new Error(resp.error);
    error.watchmanResponse = resp;
    done(error);
    return;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.cancelCommands" id="apidoc.element.fb-watchman.Client.prototype.cancelCommands">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>cancelCommands
        <span class="apidocSignatureSpan">(why)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancelCommands = function (why) {
  var error = new Error(why);

  // Steal all pending commands before we start cancellation, in
  // case something decides to schedule more commands
  var cmds = this.commands;
  this.commands = [];

  if (this.currentCommand) {
    cmds.unshift(this.currentCommand);
    this.currentCommand = null;
  }

  // Synthesize an error condition for any commands that were queued
  cmds.forEach(function(cmd) {
    cmd.cb(error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (self.bunser) {
      self.bunser.append(buf);
    }
  });
  self.socket.on(&#x27;end&#x27;, function() {
    self.socket = null;
    self.bunser = null;
    self.<span class="apidocCodeKeywordSpan">cancelCommands</span>(&#x27;The watchman connection was closed&#x27;);
    self.emit(&#x27;end&#x27;);
  });
}

// triggers will export the sock path to the environment.
// If we&#x27;re invoked in such a way, we can simply pick up the
// definition from the environment and avoid having to fork off
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.capabilityCheck" id="apidoc.element.fb-watchman.Client.prototype.capabilityCheck">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>capabilityCheck
        <span class="apidocSignatureSpan">(caps, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">capabilityCheck = function (caps, done) {
  var optional = caps.optional || [];
  var required = caps.required || [];
  var self = this;
  this.command([&#x27;version&#x27;, {
      optional: optional,
      required: required
  }], function (error, resp) {
    if (error) {
      done(error);
      return;
    }
    if (!(&#x27;capabilities&#x27; in resp)) {
      // Server doesn&#x27;t support capabilities, so we need to
      // synthesize the results based on the version
      resp = self._synthesizeCapabilityCheck(resp, optional, required);
      if (resp.error) {
        error = new Error(resp.error);
        error.watchmanResponse = resp;
        done(error);
        return;
      }
    }
    done(null, resp);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.command" id="apidoc.element.fb-watchman.Client.prototype.command">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>command
        <span class="apidocSignatureSpan">(args, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">command = function (args, done) {
  done = done || function() {};

  // Queue up the command
  this.commands.push({cmd: args, cb: done});

  // Establish a connection if we don&#x27;t already have one
  if (!this.socket) {
    if (!this.connecting) {
      this.connecting = true;
      this.connect();
      return;
    }
    return;
  }

  // If we&#x27;re already connected and idle, try sending the command immediately
  this.sendNextCommand();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return resp;
}

Client.prototype.capabilityCheck = function(caps, done) {
var optional = caps.optional || [];
var required = caps.required || [];
var self = this;
this.<span class="apidocCodeKeywordSpan">command</span>([&#x27;version&#x27;, {
    optional: optional,
    required: required
}], function (error, resp) {
  if (error) {
    done(error);
    return;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.connect" id="apidoc.element.fb-watchman.Client.prototype.connect">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
  var self = this;

  function makeSock(sockname) {
    // bunser will decode the watchman BSER protocol for us
    self.bunser = new bser.BunserBuf();
    // For each decoded line:
    self.bunser.on(&#x27;value&#x27;, function(obj) {
      // Figure out if this is a unliteral response or if it is the
      // response portion of a request-response sequence.  At the time
      // of writing, there are only two possible unilateral responses.
      var unilateral = false;
      for (var i = 0; i &#x3c; unilateralTags.length; i++) {
        var tag = unilateralTags[i];
        if (tag in obj) {
          unilateral = tag;
        }
      }

      if (unilateral) {
        self.emit(unilateral, obj);
      } else if (self.currentCommand) {
        var cmd = self.currentCommand;
        self.currentCommand = null;
        if (&#x27;error&#x27; in obj) {
          var error = new Error(obj.error);
          error.watchmanResponse = obj;
          cmd.cb(error);
        } else {
          cmd.cb(null, obj);
        }
      }

      // See if we can dispatch the next queued command, if any
      self.sendNextCommand();
    });
    self.bunser.on(&#x27;error&#x27;, function(err) {
      self.emit(&#x27;error&#x27;, err);
    });

    self.socket = net.createConnection(sockname);
    self.socket.on(&#x27;connect&#x27;, function() {
      self.connecting = false;
      self.emit(&#x27;connect&#x27;);
      self.sendNextCommand();
    });
    self.socket.on(&#x27;error&#x27;, function(err) {
      self.connecting = false;
      self.emit(&#x27;error&#x27;, err);
    });
    self.socket.on(&#x27;data&#x27;, function(buf) {
      if (self.bunser) {
        self.bunser.append(buf);
      }
    });
    self.socket.on(&#x27;end&#x27;, function() {
      self.socket = null;
      self.bunser = null;
      self.cancelCommands(&#x27;The watchman connection was closed&#x27;);
      self.emit(&#x27;end&#x27;);
    });
  }

  // triggers will export the sock path to the environment.
  // If we&#x27;re invoked in such a way, we can simply pick up the
  // definition from the environment and avoid having to fork off
  // a process to figure it out
  if (process.env.WATCHMAN_SOCK) {
    makeSock(process.env.WATCHMAN_SOCK);
    return;
  }

  // We need to ask the client binary where to find it.
  // This will cause the service to start for us if it isn&#x27;t
  // already running.
  var args = [&#x27;--no-pretty&#x27;, &#x27;get-sockname&#x27;];

  // We use the more elaborate spawn rather than exec because there
  // are some error cases on Windows where process spawning can hang.
  // It is desirable to pipe stderr directly to stderr live so that
  // we can discover the problem.
  var proc = null;
  var spawnFailed = false;

  function spawnError(error) {
    if (spawnFailed) {
      // For ENOENT, proc &#x27;close&#x27; will also trigger with a negative code,
      // let&#x27;s suppress that second error.
      return;
    }
    spawnFailed = true;
    if (error.errno === &#x27;EACCES&#x27;) {
      error.message = &#x27;The Watchman CLI is installed but cannot &#x27; +
                      &#x27;be spawned because of a permission problem&#x27;;
    } else if (error.errno === &#x27;ENOENT&#x27;) {
      error.message = &#x27;Watchman was not found in PATH.  See &#x27; +
          &#x27;https://facebook.github.io/watchman/docs/install.html &#x27; +
          &#x27;for installation instructions&#x27;;
    }
    console.error(&#x27;Watchman: &#x27;, error.message);
    self.emit(&#x27;error&#x27;, error);
  }

  try {
    proc = childProcess.spawn(this.watchmanBinaryPath, args, {
      stdio: [&#x27;ignore&#x27;, &#x27;pipe&#x27;, &#x27;pipe&#x27;]
    });
  } catch (error) {
    spawnError(error);
    return;
  }

  var stdout = [];
  var stderr = [];
  proc.stdout.on(&#x27;data&#x27;, function(data) {
    stdout.push(data);
  });
  proc.stderr.on(&#x27;data&#x27;, function(data) {
    data = data.toString(&#x27;utf8&#x27;);
    stderr.push(data);
    console.error(data);
  });
  proc.on(&#x27;error&#x27;, function(error) {
    spawnError(error);
  });

  proc.on(&#x27;close&#x27;, function (code, signal) {
    if (code !== 0) {
      spawnError(new Error(
          self.watchmanBinaryPath + &#x27; &#x27; + args.join(&#x27; &#x27;) +
          &#x27; returned with exit code=&#x27; + code + &#x27;, signal=&#x27; +
          signal + &#x27;, stderr= &#x27; + stderr.join(&#x27;&#x27;)));
      return;
    }
    try { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Queue up the command
this.commands.push({cmd: args, cb: done});

// Establish a connection if we don&#x27;t already have one
if (!this.socket) {
  if (!this.connecting) {
    this.connecting = true;
    this.<span class="apidocCodeKeywordSpan">connect</span>();
    return;
  }
  return;
}

// If we&#x27;re already connected and idle, try sending the command immediately
this.sendNextCommand();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.end" id="apidoc.element.fb-watchman.Client.prototype.end">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">end = function () {
  this.cancelCommands(&#x27;The client was ended&#x27;);
  if (this.socket) {
    this.socket.end();
    this.socket = null;
  }
  this.bunser = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}

// Close the connection to the service
Client.prototype.end = function() {
  this.cancelCommands(&#x27;The client was ended&#x27;);
  if (this.socket) {
    this.socket.<span class="apidocCodeKeywordSpan">end</span>();
    this.socket = null;
  }
  this.bunser = null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fb-watchman.Client.prototype.sendNextCommand" id="apidoc.element.fb-watchman.Client.prototype.sendNextCommand">
        function <span class="apidocSignatureSpan">fb-watchman.Client.prototype.</span>sendNextCommand
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendNextCommand = function () {
  if (this.currentCommand) {
    // There&#x27;s a command pending response, don&#x27;t send this new one yet
    return;
  }

  this.currentCommand = this.commands.shift();
  if (!this.currentCommand) {
    // No further commands are queued
    return;
  }

  this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      cmd.cb(error);
    } else {
      cmd.cb(null, obj);
    }
  }

  // See if we can dispatch the next queued command, if any
  self.<span class="apidocCodeKeywordSpan">sendNextCommand</span>();
});
self.bunser.on(&#x27;error&#x27;, function(err) {
  self.emit(&#x27;error&#x27;, err);
});

self.socket = net.createConnection(sockname);
self.socket.on(&#x27;connect&#x27;, function() {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
